package eighthtask.oop.OOPprinciples;

//  Наследование позволяет создавать новый класс на основе существующего, унаследовав его свойства и методы.
//  Это способствует повторному использованию кода и созданию иерархий классов.

//  С помощью наследования можно расширить функционал уже имеющихся классов за счет добавления нового функционала или изменения старого.

//  Чтобы объявить один класс наследником от другого, надо использовать после имени класса-наследника ключевое слово extends,
//  после которого идет имя базового класса.
public class Employee extends Person2 {

    String company;
//  Если в базовом классе определены конструкторы, то в конструкторе производного классы необходимо вызвать
//  один из конструкторов базового класса с помощью ключевого слова super.

//  При вызове конструктора после слова super в скобках идет перечисление передаваемых аргументов.
//  При этом вызов конструктора базового класса должен идти в самом начале в конструкторе производного класса.
//  Таким образом, установка имени сотрудника делегируется конструктору базового класса.
//
//  Причем даже если производный класс никакой другой работы не производит в конструкторе, как в примере выше,
//  все равно необходимо вызвать конструктор базового класса.
    public Employee(String name, int age) {
        super(name, age);
    }

//     опционально
//    public Employee(int age) {
//        super(age);
//    }
//
//    public Employee(String name) {
//        super(name);
//    }

    public Employee(String name, int age, String company) {
        super(name, age);
        this.company = company;
    }

//    Производный класс имеет доступ ко всем методам и полям базового класса (даже если базовый класс находится в другом пакете)
//    кроме тех, которые определены с модификатором private. При этом производный класс также может добавлять свои поля и методы:

//    В данном случае класс Employee добавляет поле company, которое хранит место работы сотрудника, а также метод work.
    public void work(){
        System.out.printf("%s works in %s \n", getName(), company);
    }

//    Полиморфизм позволяет объектам одного и того же типа вести себя по-разному в зависимости от контекста.
//    В Java это может быть реализовано через переопределение методов (override) и перегрузку методов (overload).
//    Переопределение позволяет подклассу предоставить специфическую реализацию метода суперкласса

//    Производный класс может определять свои методы, а может переопределять методы, которые унаследованы от базового класса.
//    Перед переопределяемым методом указывается аннотация @Override. Данная аннотация в принципе необязательна.
//
//    При переопределении метода он должен иметь уровень доступа не меньше, чем уровень доступа в базовом класса.
//    Например, если в базовом классе метод имеет модификатор public, то и в производном классе метод должен иметь модификатор public.
    @Override
    public void speak() {
//      С помощью ключевого слова super мы также можем обратиться к реализации методов базового класса.
        super.speak();
        System.out.printf("Works in %s \n", company);
    }

    @Override
    public String displayInfo() {
        return "это класс Employee";
    }
}
